/**
 * @file libDM_mavlink_structs.hpp
 * @brief This file contains the definition of MAVLINK_MSG and MAVLINK_MSG_LIST structs.
 *
 * MAVLINK_MSG is an internal struct to handle any mavlink message and extract any information.
 * It stores only binary representation of the messages. Decoding has to be done by the user using
 * the mavlink autogenerated code.
 *
 * MAVLINK_MSG_LIST is a vector of subset of references to MAVLINK_MSG stored in mMsgs. It allows to
 * avoid search in the mMsgs vector when wanting to access a specific message.
 */
#include <Arduino.h>
#include <vector>
#include <map>
#include "libDM_stream_logger.hpp"

// Mavlink options
#define MAVLINK_USE_MESSAGE_INFO

// Mavlink autogenerated code
#include "autogen_mavlink/mavlink_types.h"
#include "autogen_mavlink/sysrox/mavlink.h"

/**
 * @brief MAVLINK hardware interface type
 */
enum class MAVLINK_SOURCE : uint8_t
{
    SOURCE_SERIAL = 0, // Serial
    SOURCE_BLE    = 1, // Bluetooth Low Energy
    SOURCE_WIFI   = 2, // WIFI
};

// ====================================================== //
// =================== Mavlink structs ================== //
// ====================================================== //
// Internal struct to handle any mavlink message and extract any information. To simplify the
// comprehension of the code, the choice has been made to store only binary representation of the
// messages. Decoding has to be done by the user using the mavlink autogenerated code.

/**
 * @brief Internal struct to handle any mavlink message and extract any information using the ID
 * @details To simplify the comprehension of the code, the choice has been made to store only binary
 * representation of the messages. Decoding has to be done by the user using the mavlink
 * autogenerated code.
 */
struct MAVLINK_MSG
{
    /**
     * @brief A class representing a MAVLink message.
     * @details This class provides a convenient way to construct and manipulate MAVLink messages.
     * It contains fields for the message ID, payload, and checksum, as well as methods for
     * encoding and decoding the message.
     */
    explicit MAVLINK_MSG(uint32_t msgId) :
        mMsgID(msgId), mMsgInfo(*mavlink_get_message_info_by_id(msgId))
    {
        mMsgName = mMsgInfo.name;
    }

    /**
     * @brief Returns the last received MAVLink message (raw generci mavlink struct)
     * @param isNewFlagToFalse If true, sets the "is new" flag to false after returning the message.
     * @return A reference to the last received MAVLink message raw struct.
     */
    const mavlink_message_t& getMavlinkMsg(bool isNewFlagToFalse = true)
    {
        if (isNewFlagToFalse)
            mIsNew = false;
        return mMsg;
    }

    /**
     * @brief Updates the internal state of the library with the data from a received MAVLink
     * message.
     * @details This function should be called whenever a new MAVLink message is received by the
     * library. It updates the internal state of the library with the data from the message, so that
     * the data can be read by the user.
     * @param msg The MAVLink message to update the internal state with.
     */
    void updateMsgForRead(const mavlink_message_t& msg)
    {
        mMsg   = msg;
        mIsNew = true;
    }

    /**
     * @brief Updates the message for sending.
     * @details This function updates the message that needs to be sent on the hardware stream.
     * @param msg The `mavlink_message_t` object to update.
     */
    void updateMsgForSend(const mavlink_message_t& msg)
    {
        mMsg            = msg;
        mIsReadyForSend = true;
    }

    /**
     * @brief Prints the message information.
     * @details This function prints the message informations which include message ID, message
     * name, and message length.
     * @param streamObj A pointer to the streamLogger object to use for printing and logging.
     */
    inline void printInfos(streamLogger* streamObj) const // print the message informations
    {
        streamObj->printlnUlog(true, true, "\t Message name: " + mMsgName, false);
        streamObj->printlnUlog(true, true, "\t Message ID: " + String(mMsgID), false);
        streamObj->printlnUlog(
                true, true, "\t Message fields number: " + String(mMsgInfo.num_fields), false);

        for (size_t i = 0; i < mMsgInfo.num_fields; i++)
            printFieldInfos(mMsgInfo.fields[i], i, streamObj);
    }

    /**
     * @brief Checks if the specified interface is available for sending messages.
     * @param source The MAVLink source to check.
     * @return True if the interface is available for sending messages, false otherwise.
     */
    inline bool isSendingInterface(
            const MAVLINK_SOURCE source) // Check is interface is available for sending message
    {
        return std::find(mSendInterfaces.begin(), mSendInterfaces.end(), source)
               != mSendInterfaces.end();
    }

    // NOLINTBEGIN(cppcoreguidelines-non-private-member-variables-in-classes,misc-non-private-member-variables-in-classes)
    bool mIsNew                                 = false;
    bool mIsEnabled                             = true;
    bool mIsReadyForSend                        = false;
    String mMsgName                             = "";
    uint32_t mMsgID                             = 0U;
    mavlink_message_info_t mMsgInfo             = mavlink_message_info_t();
    std::vector<MAVLINK_SOURCE> mSendInterfaces = {};
    // NOLINTEND(cppcoreguidelines-non-private-member-variables-in-classes,misc-non-private-member-variables-in-classes)

private:
    void printFieldInfos(mavlink_field_info_t field,
                         uint32_t fieldNumber,
                         streamLogger* streamObj) const // print a field informations
    {
        String fieldInfosStr = "\t" + String(fieldNumber) + ". Field name: " + String(field.name);
        String typeStr       = "unknown";
        String dimensionStr  = "";
        switch (field.type)
        {
        case MAVLINK_TYPE_CHAR:
            typeStr = "char";
            break;

        case MAVLINK_TYPE_UINT8_T:
            typeStr = "uint8_t";
            break;

        case MAVLINK_TYPE_INT8_T:
            typeStr = "int8_t";
            break;

        case MAVLINK_TYPE_UINT16_T:
            typeStr = "uint16_t";
            break;

        case MAVLINK_TYPE_INT16_T:
            typeStr = "int16_t";
            break;

        case MAVLINK_TYPE_UINT32_T:
            typeStr = "uint32_t";
            break;

        case MAVLINK_TYPE_INT32_T:
            typeStr = "int32_t";
            break;

        case MAVLINK_TYPE_UINT64_T:
            typeStr = "uint64_t";
            break;

        case MAVLINK_TYPE_INT64_T:
            typeStr = "int64_t";
            break;

        case MAVLINK_TYPE_FLOAT:
            typeStr = "float";
            break;

        case MAVLINK_TYPE_DOUBLE:
            typeStr = "double";
            break;

        default:
            break;
        }
        fieldInfosStr += " / Type: " + typeStr;

        if (field.array_length > 0)
            dimensionStr = " / Dimension: vector, with length = " + String(field.array_length);
        else
            dimensionStr = " / Dimension: scalar";

        fieldInfosStr += dimensionStr;

        streamObj->printlnUlog(true, true, fieldInfosStr, false);
    }

    mavlink_message_t mMsg = mavlink_message_t();

    // ~~~~~~~~~~~~~~ Class name ~~~~~~~~~~~~~ //
    String mClassName = "MAVLINK_MSG";
};

/**
 * @brief MAVLINK_MSG_LIST is a vector of subset of references to MAVLINK_MSG stored in mMsgs
 * @details It allows to avoid search in the mMsgs vector when wanting to access a specific message
 * @warning Do not try to create this struct directly, extract a subset of
 * MAVLINK_UTILS::getMonitoredMsgsList() or MAVLINK_UTILS::getMsgsToSendList
 */
struct MAVLINK_MSG_LIST
{
    MAVLINK_MSG_LIST() = default;

    /**
     * @brief Returns the last message of the given ID.
     * @details This function returns the last message of the given ID that was received by the
     * MAVLink communication interface. If the `isNewFlagToFalse` parameter is set to `true`
     * (default), the "isNew" flag of the returned message will be set to `false` when calling the
     * function
     * @param msgID The ID of the message to retrieve.
     * @param isNewFlagToFalse If `true`, the "isNew" flag of the returned message will be set to
     * `false`.
     * @return A pointer to the last message of the given ID.
     */
    MAVLINK_MSG* getMsg(uint32_t msgID, bool isNewFlagToFalse = true) const

    {
        if (!isIDMonitored(msgID))
            return mMsgRefsList.at(0);

        MAVLINK_MSG* mavlinkMsg = mMsgRefsList.at(mMsgsIDToMsgsRefsIndex.at(msgID));

        if (isNewFlagToFalse)
            mavlinkMsg->mIsNew = false;

        return mavlinkMsg;
    }

    /**
     * @brief Get the isNew flag of the given message ID.
     * @param msgID The ID of the message to check.
     * @return True if the message is new, false otherwise.
     */
    bool getIsNew(uint32_t msgID)
    {
        if (!isIDMonitored(msgID))
            return false;

        return mMsgRefsList.at(mMsgsIDToMsgsRefsIndex.at(msgID))->mIsNew;
    }

    /**
     * @brief Gets the isReadyForSend flag of the given message ID.
     * @param msgID The ID of the message to check.
     * @return True if the message is ready to be sent, false otherwise.
     */
    bool getReadyForSend(uint32_t msgID) // get the isReadyForSend flag of the given ID
    {
        if (!isIDMonitored(msgID))
            return false;

        return mMsgRefsList.at(mMsgsIDToMsgsRefsIndex.at(msgID))->mIsReadyForSend;
    }

    /**
     * @brief Returns a const reference to the list of MAVLink message pointers.
     * @return const std::vector<MAVLINK_MSG*>& A const reference to the list of MAVLink message
     * pointers.
     */
    const std::vector<MAVLINK_MSG*>& getMsgRefsList()
    {
        return mMsgRefsList;
    }

    /**
     * @brief Adds a MAVLink message to the list.
     * @param msg Pointer to the MAVLink message to add.
     */
    inline void addMsg(MAVLINK_MSG* msg) // add a message to the list
    {
        mMsgRefsList.push_back(msg);
        mMsgsIDToMsgsRefsIndex[msg->mMsgID] = mMsgsIDs.size();
        mMsgsIDs.push_back(msg->mMsgID);
    }

    /**
     * @brief Returns a subset of the MAVLINK_MSG_LIST containing only messages with IDs in the
     * provided list.
     * @param msgIDList A vector of uint32_t values representing the IDs of the messages to include
     * in the subset.
     * @return A MAVLINK_MSG_LIST object containing only the messages with IDs in the provided list.
     */
    MAVLINK_MSG_LIST getSubset(const std::vector<uint32_t>& msgIDList) const
    {
        MAVLINK_MSG_LIST subset = MAVLINK_MSG_LIST();
#pragma unroll
        for (size_t i = 0; i < msgIDList.size(); i++)
        {
            if (isIDMonitored(msgIDList[i]))
                subset.addMsg(mMsgRefsList.at(mMsgsIDToMsgsRefsIndex.at(msgIDList[i])));
        }
        return subset;
    }
    inline bool isIDMonitored(const uint32_t msgID) const
    {
        return std::find(mMsgsIDs.begin(), mMsgsIDs.end(), msgID) != mMsgsIDs.end();
    }

private:
    std::vector<uint32_t> mMsgsIDs = {}; // list of all monitored messages IDs inside this list
    std::vector<MAVLINK_MSG*> mMsgRefsList = {}; // list of references to the monitored messages
    std::map<uint32_t, uint32_t> mMsgsIDToMsgsRefsIndex =
            {}; // map to retrieve the index of the message reference in the mMsgRefsList
                // vector from the message ID
};