#include "libDM_mavlink.hpp"
#include "libDM_generic_operations.hpp"

// Mavlink options
#define MAVLINK_USE_MESSAGE_INFO

// ====================================================== //
// ================ Main class functions ================ //
// ====================================================== //

bool MAVLINK_UTILS::initiateLogging()
{
    bool res = false;

    // Create vectors with names and ID of complete messages list
    std::vector<String> msgsNames = {};
    std::vector<uint32_t> msgsIDs = {};

    for (size_t i = 0; i < mMsgsMonitored->size(); i++)
    {
        msgsNames.push_back(mMsgsMonitored->at(i).mMsgName);
        msgsIDs.push_back(mMsgsMonitored->at(i).mMsgID);
    }

    for (size_t i = 0; i < mMsgsToSend->size(); i++)
    {
        msgsNames.push_back(mMsgsToSend->at(i).mMsgName);
        msgsIDs.push_back(mMsgsToSend->at(i).mMsgID);
    }

    res = mStreamObj->writeMavlinkHeaderAndId(msgsNames, msgsIDs);
    if (res)
        mStreamObj->printlnUlog(true, true, mClassName + ": logging configuration successful");
    else
        mStreamObj->printlnUlog(true, true, mClassName + ": logging configuration failed");

    mIsLoggerReady = res;

    return res;
}

void MAVLINK_UTILS::addMsgToMonitor(uint32_t msgID)
{
    // Check if the message is already monitored
    if (std::find(mMsgsIDs.begin(), mMsgsIDs.end(), msgID) != mMsgsIDs.end())
    {
        mStreamObj->printlnUlog(
                true, true, mClassName + ": Message ID " + String(msgID) + " is already monitored");
        return;
    }

    // Get the message value from mavlink autogenerated code
    MAVLINK_MSG mavlinkMsg(msgID);
    mMsgsMonitored->push_back(mavlinkMsg);
    mMsgsMonitoredRefs.addMsg(&mMsgsMonitored->back());
    mStreamObj->printlnUlog(
            true, true, mClassName + ": added message to monitoring list ID = " + String(msgID));
    mavlinkMsg.printInfos(mStreamObj);

    mMsgsIDToMsgsMonitoredIndex[msgID] = mMsgsIDs.size();
    mMsgsIDs.push_back(msgID);
}

void MAVLINK_UTILS::addMsgToSendingList(uint32_t msgID,
                                        const std::vector<MAVLINK_SOURCE>& sendingInterfaces)
{
    // Check if the message is already in sending list
    if (std::find(mMsgsToSendIDs.begin(), mMsgsToSendIDs.end(), msgID) != mMsgsToSendIDs.end())
    {
        mStreamObj->printlnUlog(true,
                                true,
                                mClassName + ": Message ID " + String(msgID)
                                        + " is already in sending list");
        return;
    }

    MAVLINK_MSG mavlinkMsg(msgID);
    mavlinkMsg.mSendInterfaces = sendingInterfaces;
    mMsgsToSend->push_back(mavlinkMsg);
    mMsgsToSendRefs.addMsg(&mMsgsToSend->back());
    mStreamObj->printlnUlog(
            true, true, mClassName + ": added message to sending list ID = " + String(msgID));
    mavlinkMsg.printInfos(mStreamObj);

    mMsgsIDToMsgsToSendIndex[msgID] = mMsgsToSendIDs.size();
    mMsgsToSendIDs.push_back(msgID);
}

// ====================================================== //
// ============== Monitoring bus functions ============== //
// ====================================================== //

bool MAVLINK_UTILS::addMavlinkStream(HardwareSerial* serialObj)
{
    if (mSerialObj != NULL)
    {
        mStreamObj->printlnUlog(true, true, mClassName + ": Serial object already set");
        return false; // NOLINT
    }

    mStreamObj->printlnUlog(true, true, mClassName + ": Serial object provided for mavlink stream");

    // Serial stream has to be already started by user at the correct speed
    mSerialObj = serialObj;
    mSources.push_back(MAVLINK_SOURCE::SOURCE_SERIAL);

    return true;
}

void MAVLINK_UTILS::updateMonitoredMessages(const uint8_t* buffer, size_t bufferLength)
{

    mavlink_status_t status  = mavlink_status_t();
    mavlink_message_t rawMsg = mavlink_message_t();
    int chan                 = MAVLINK_COMM_0;

#pragma unroll
    for (size_t i = 0; i < bufferLength; i++)
    {
        if (mavlink_parse_char(chan, buffer[i], &rawMsg, &status))
        {
            // Check if the message is monitored
            if (mMsgsMonitoredRefs.isIDMonitored(rawMsg.msgid))
            {
                // Get the message reference
                MAVLINK_MSG* mavlinkMsg = mMsgsMonitoredRefs.getMsg(rawMsg.msgid);

                if (mavlinkMsg->mIsEnabled)
                {
                    // Update the message content
                    mavlinkMsg->updateMsgForRead(rawMsg);

                    if (mIsLoggerReady)
                    {
                        // Log message, reserialization is needed
                        uint8_t inBuffer[MAVLINK_MAX_PACKET_LEN];
                        uint16_t len = mavlink_msg_to_send_buffer(inBuffer, &rawMsg);
                        mStreamObj->updateProtobufProtocolLogBuffer(
                                inBuffer, len, EVENT_TYPE::MAVLINK, RX_TX::RX);
                    }
                }
            }
        }
    }
    mStatus = status;

    // TODO: Add other sources
}

// ====================================================== //
// ================== Sending functions ================= //
// ====================================================== //

void MAVLINK_UTILS::sendMessages()
{
    std::vector<MAVLINK_MSG*> mavlinkMsgList = mMsgsToSendRefs.getMsgRefsList();
    for (size_t i = 0; i < mavlinkMsgList.size(); i++)
    {
        MAVLINK_MSG* mavlinkMsg = mavlinkMsgList[i];

        // Check if the message is ready to be sent
        if (mavlinkMsg->mIsReadyForSend)
        {
            // Send the message on serial
            if (isSource(MAVLINK_SOURCE::SOURCE_SERIAL)
                && mavlinkMsg->isSendingInterface(MAVLINK_SOURCE::SOURCE_SERIAL))
                sendMessage(MAVLINK_SOURCE::SOURCE_SERIAL, mavlinkMsg->getMavlinkMsg());

            // TODO: Add other sources

            mavlinkMsg->mIsReadyForSend = false;
        }
    }
}

bool MAVLINK_UTILS::sendMessage(MAVLINK_SOURCE source, const mavlink_message_t& msg)
{
    if (source == MAVLINK_SOURCE::SOURCE_SERIAL)
    {
        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];
        uint16_t len = mavlink_msg_to_send_buffer(buffer, &msg);

        // Log message
        if (mIsLoggerReady)
            mStreamObj->updateProtobufProtocolLogBuffer(
                    buffer, len, EVENT_TYPE::MAVLINK, RX_TX::TX);

        return (mSerialObj->write(buffer, len) == len);
    }

    // TODO: Add other sources

    return false;
}

bool MAVLINK_UTILS::sendMessage(const std::vector<MAVLINK_SOURCE>& sources,
                                const mavlink_message_t& msg)
{
    bool success = true;
    for (size_t i = 0; i < sources.size(); i++)
        success &= sendMessage(sources[i], msg);

    return success;
}
